{"ast":null,"code":"import _classCallCheck from \"/home/j0aki/Desktop/Develop/Henry/PI-Food-main/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/j0aki/Desktop/Develop/Henry/PI-Food-main/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nvar defaultOpts = {\n  withStartIndices: false,\n  withEndIndices: false,\n  xmlMode: false\n};\nexport var DomHandler = /*#__PURE__*/function () {\n  /**\n   * @param callback Called once parsing has completed.\n   * @param options Settings for the handler.\n   * @param elementCB Callback whenever a tag is closed.\n   */\n  function DomHandler(callback, options, elementCB) {\n    _classCallCheck(this, DomHandler);\n    /** The elements of the DOM */\n    this.dom = [];\n    /** The root element for the DOM */\n    this.root = new Document(this.dom);\n    /** Indicated whether parsing has been completed. */\n    this.done = false;\n    /** Stack of open tags. */\n    this.tagStack = [this.root];\n    /** A data node that is still being written to. */\n    this.lastNode = null;\n    /** Reference to the parser instance. Used for location information. */\n    this.parser = null;\n    // Make it possible to skip arguments, for backwards-compatibility\n    if (typeof options === \"function\") {\n      elementCB = options;\n      options = defaultOpts;\n    }\n    if (typeof callback === \"object\") {\n      options = callback;\n      callback = undefined;\n    }\n    this.callback = callback !== null && callback !== void 0 ? callback : null;\n    this.options = options !== null && options !== void 0 ? options : defaultOpts;\n    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n  }\n  _createClass(DomHandler, [{\n    key: \"onparserinit\",\n    value: function onparserinit(parser) {\n      this.parser = parser;\n    }\n    // Resets the handler back to starting state\n  }, {\n    key: \"onreset\",\n    value: function onreset() {\n      this.dom = [];\n      this.root = new Document(this.dom);\n      this.done = false;\n      this.tagStack = [this.root];\n      this.lastNode = null;\n      this.parser = null;\n    }\n    // Signals the handler that parsing is done\n  }, {\n    key: \"onend\",\n    value: function onend() {\n      if (this.done) return;\n      this.done = true;\n      this.parser = null;\n      this.handleCallback(null);\n    }\n  }, {\n    key: \"onerror\",\n    value: function onerror(error) {\n      this.handleCallback(error);\n    }\n  }, {\n    key: \"onclosetag\",\n    value: function onclosetag() {\n      this.lastNode = null;\n      var elem = this.tagStack.pop();\n      if (this.options.withEndIndices) {\n        elem.endIndex = this.parser.endIndex;\n      }\n      if (this.elementCB) this.elementCB(elem);\n    }\n  }, {\n    key: \"onopentag\",\n    value: function onopentag(name, attribs) {\n      var type = this.options.xmlMode ? ElementType.Tag : undefined;\n      var element = new Element(name, attribs, undefined, type);\n      this.addNode(element);\n      this.tagStack.push(element);\n    }\n  }, {\n    key: \"ontext\",\n    value: function ontext(data) {\n      var lastNode = this.lastNode;\n      if (lastNode && lastNode.type === ElementType.Text) {\n        lastNode.data += data;\n        if (this.options.withEndIndices) {\n          lastNode.endIndex = this.parser.endIndex;\n        }\n      } else {\n        var node = new Text(data);\n        this.addNode(node);\n        this.lastNode = node;\n      }\n    }\n  }, {\n    key: \"oncomment\",\n    value: function oncomment(data) {\n      if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n        this.lastNode.data += data;\n        return;\n      }\n      var node = new Comment(data);\n      this.addNode(node);\n      this.lastNode = node;\n    }\n  }, {\n    key: \"oncommentend\",\n    value: function oncommentend() {\n      this.lastNode = null;\n    }\n  }, {\n    key: \"oncdatastart\",\n    value: function oncdatastart() {\n      var text = new Text(\"\");\n      var node = new CDATA([text]);\n      this.addNode(node);\n      text.parent = node;\n      this.lastNode = text;\n    }\n  }, {\n    key: \"oncdataend\",\n    value: function oncdataend() {\n      this.lastNode = null;\n    }\n  }, {\n    key: \"onprocessinginstruction\",\n    value: function onprocessinginstruction(name, data) {\n      var node = new ProcessingInstruction(name, data);\n      this.addNode(node);\n    }\n  }, {\n    key: \"handleCallback\",\n    value: function handleCallback(error) {\n      if (typeof this.callback === \"function\") {\n        this.callback(error, this.dom);\n      } else if (error) {\n        throw error;\n      }\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      var parent = this.tagStack[this.tagStack.length - 1];\n      var previousSibling = parent.children[parent.children.length - 1];\n      if (this.options.withStartIndices) {\n        node.startIndex = this.parser.startIndex;\n      }\n      if (this.options.withEndIndices) {\n        node.endIndex = this.parser.endIndex;\n      }\n      parent.children.push(node);\n      if (previousSibling) {\n        node.prev = previousSibling;\n        previousSibling.next = node;\n      }\n      node.parent = parent;\n      this.lastNode = null;\n    }\n  }]);\n  return DomHandler;\n}();\nexport default DomHandler;","map":{"version":3,"names":["ElementType","Element","Text","Comment","CDATA","Document","ProcessingInstruction","defaultOpts","withStartIndices","withEndIndices","xmlMode","DomHandler","callback","options","elementCB","_classCallCheck","dom","root","done","tagStack","lastNode","parser","undefined","_createClass","key","value","onparserinit","onreset","onend","handleCallback","onerror","error","onclosetag","elem","pop","endIndex","onopentag","name","attribs","type","Tag","element","addNode","push","ontext","data","node","oncomment","oncommentend","oncdatastart","text","parent","oncdataend","onprocessinginstruction","length","previousSibling","children","startIndex","prev","next"],"sources":["/home/j0aki/Desktop/Develop/Henry/PI-Food-main/client/node_modules/html-react-parser/node_modules/domhandler/lib/esm/index.js"],"sourcesContent":["import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction, } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nconst defaultOpts = {\n    withStartIndices: false,\n    withEndIndices: false,\n    xmlMode: false,\n};\nexport class DomHandler {\n    /**\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */\n    constructor(callback, options, elementCB) {\n        /** The elements of the DOM */\n        this.dom = [];\n        /** The root element for the DOM */\n        this.root = new Document(this.dom);\n        /** Indicated whether parsing has been completed. */\n        this.done = false;\n        /** Stack of open tags. */\n        this.tagStack = [this.root];\n        /** A data node that is still being written to. */\n        this.lastNode = null;\n        /** Reference to the parser instance. Used for location information. */\n        this.parser = null;\n        // Make it possible to skip arguments, for backwards-compatibility\n        if (typeof options === \"function\") {\n            elementCB = options;\n            options = defaultOpts;\n        }\n        if (typeof callback === \"object\") {\n            options = callback;\n            callback = undefined;\n        }\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n    }\n    onparserinit(parser) {\n        this.parser = parser;\n    }\n    // Resets the handler back to starting state\n    onreset() {\n        this.dom = [];\n        this.root = new Document(this.dom);\n        this.done = false;\n        this.tagStack = [this.root];\n        this.lastNode = null;\n        this.parser = null;\n    }\n    // Signals the handler that parsing is done\n    onend() {\n        if (this.done)\n            return;\n        this.done = true;\n        this.parser = null;\n        this.handleCallback(null);\n    }\n    onerror(error) {\n        this.handleCallback(error);\n    }\n    onclosetag() {\n        this.lastNode = null;\n        const elem = this.tagStack.pop();\n        if (this.options.withEndIndices) {\n            elem.endIndex = this.parser.endIndex;\n        }\n        if (this.elementCB)\n            this.elementCB(elem);\n    }\n    onopentag(name, attribs) {\n        const type = this.options.xmlMode ? ElementType.Tag : undefined;\n        const element = new Element(name, attribs, undefined, type);\n        this.addNode(element);\n        this.tagStack.push(element);\n    }\n    ontext(data) {\n        const { lastNode } = this;\n        if (lastNode && lastNode.type === ElementType.Text) {\n            lastNode.data += data;\n            if (this.options.withEndIndices) {\n                lastNode.endIndex = this.parser.endIndex;\n            }\n        }\n        else {\n            const node = new Text(data);\n            this.addNode(node);\n            this.lastNode = node;\n        }\n    }\n    oncomment(data) {\n        if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n            this.lastNode.data += data;\n            return;\n        }\n        const node = new Comment(data);\n        this.addNode(node);\n        this.lastNode = node;\n    }\n    oncommentend() {\n        this.lastNode = null;\n    }\n    oncdatastart() {\n        const text = new Text(\"\");\n        const node = new CDATA([text]);\n        this.addNode(node);\n        text.parent = node;\n        this.lastNode = text;\n    }\n    oncdataend() {\n        this.lastNode = null;\n    }\n    onprocessinginstruction(name, data) {\n        const node = new ProcessingInstruction(name, data);\n        this.addNode(node);\n    }\n    handleCallback(error) {\n        if (typeof this.callback === \"function\") {\n            this.callback(error, this.dom);\n        }\n        else if (error) {\n            throw error;\n        }\n    }\n    addNode(node) {\n        const parent = this.tagStack[this.tagStack.length - 1];\n        const previousSibling = parent.children[parent.children.length - 1];\n        if (this.options.withStartIndices) {\n            node.startIndex = this.parser.startIndex;\n        }\n        if (this.options.withEndIndices) {\n            node.endIndex = this.parser.endIndex;\n        }\n        parent.children.push(node);\n        if (previousSibling) {\n            node.prev = previousSibling;\n            previousSibling.next = node;\n        }\n        node.parent = parent;\n        this.lastNode = null;\n    }\n}\nexport default DomHandler;\n"],"mappings":";;AAAA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,qBAAqB,QAAS,WAAW;AAC3F,cAAc,WAAW;AACzB;AACA,IAAMC,WAAW,GAAG;EAChBC,gBAAgB,EAAE,KAAK;EACvBC,cAAc,EAAE,KAAK;EACrBC,OAAO,EAAE;AACb,CAAC;AACD,WAAaC,UAAU;EACnB;AACJ;AACA;AACA;AACA;EACI,SAAAA,WAAYC,QAAQ,EAAEC,OAAO,EAAEC,SAAS,EAAE;IAAAC,eAAA,OAAAJ,UAAA;IACtC;IACA,IAAI,CAACK,GAAG,GAAG,EAAE;IACb;IACA,IAAI,CAACC,IAAI,GAAG,IAAIZ,QAAQ,CAAC,IAAI,CAACW,GAAG,CAAC;IAClC;IACA,IAAI,CAACE,IAAI,GAAG,KAAK;IACjB;IACA,IAAI,CAACC,QAAQ,GAAG,CAAC,IAAI,CAACF,IAAI,CAAC;IAC3B;IACA,IAAI,CAACG,QAAQ,GAAG,IAAI;IACpB;IACA,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB;IACA,IAAI,OAAOR,OAAO,KAAK,UAAU,EAAE;MAC/BC,SAAS,GAAGD,OAAO;MACnBA,OAAO,GAAGN,WAAW;IACzB;IACA,IAAI,OAAOK,QAAQ,KAAK,QAAQ,EAAE;MAC9BC,OAAO,GAAGD,QAAQ;MAClBA,QAAQ,GAAGU,SAAS;IACxB;IACA,IAAI,CAACV,QAAQ,GAAGA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,IAAI;IAC1E,IAAI,CAACC,OAAO,GAAGA,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAGA,OAAO,GAAGN,WAAW;IAC7E,IAAI,CAACO,SAAS,GAAGA,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,IAAI;EAClF;EAACS,YAAA,CAAAZ,UAAA;IAAAa,GAAA;IAAAC,KAAA,EACD,SAAAC,aAAaL,MAAM,EAAE;MACjB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACxB;IACA;EAAA;IAAAG,GAAA;IAAAC,KAAA,EACA,SAAAE,QAAA,EAAU;MACN,IAAI,CAACX,GAAG,GAAG,EAAE;MACb,IAAI,CAACC,IAAI,GAAG,IAAIZ,QAAQ,CAAC,IAAI,CAACW,GAAG,CAAC;MAClC,IAAI,CAACE,IAAI,GAAG,KAAK;MACjB,IAAI,CAACC,QAAQ,GAAG,CAAC,IAAI,CAACF,IAAI,CAAC;MAC3B,IAAI,CAACG,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACC,MAAM,GAAG,IAAI;IACtB;IACA;EAAA;IAAAG,GAAA;IAAAC,KAAA,EACA,SAAAG,MAAA,EAAQ;MACJ,IAAI,IAAI,CAACV,IAAI,EACT;MACJ,IAAI,CAACA,IAAI,GAAG,IAAI;MAChB,IAAI,CAACG,MAAM,GAAG,IAAI;MAClB,IAAI,CAACQ,cAAc,CAAC,IAAI,CAAC;IAC7B;EAAC;IAAAL,GAAA;IAAAC,KAAA,EACD,SAAAK,QAAQC,KAAK,EAAE;MACX,IAAI,CAACF,cAAc,CAACE,KAAK,CAAC;IAC9B;EAAC;IAAAP,GAAA;IAAAC,KAAA,EACD,SAAAO,WAAA,EAAa;MACT,IAAI,CAACZ,QAAQ,GAAG,IAAI;MACpB,IAAMa,IAAI,GAAG,IAAI,CAACd,QAAQ,CAACe,GAAG,EAAE;MAChC,IAAI,IAAI,CAACrB,OAAO,CAACJ,cAAc,EAAE;QAC7BwB,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACd,MAAM,CAACc,QAAQ;MACxC;MACA,IAAI,IAAI,CAACrB,SAAS,EACd,IAAI,CAACA,SAAS,CAACmB,IAAI,CAAC;IAC5B;EAAC;IAAAT,GAAA;IAAAC,KAAA,EACD,SAAAW,UAAUC,IAAI,EAAEC,OAAO,EAAE;MACrB,IAAMC,IAAI,GAAG,IAAI,CAAC1B,OAAO,CAACH,OAAO,GAAGV,WAAW,CAACwC,GAAG,GAAGlB,SAAS;MAC/D,IAAMmB,OAAO,GAAG,IAAIxC,OAAO,CAACoC,IAAI,EAAEC,OAAO,EAAEhB,SAAS,EAAEiB,IAAI,CAAC;MAC3D,IAAI,CAACG,OAAO,CAACD,OAAO,CAAC;MACrB,IAAI,CAACtB,QAAQ,CAACwB,IAAI,CAACF,OAAO,CAAC;IAC/B;EAAC;IAAAjB,GAAA;IAAAC,KAAA,EACD,SAAAmB,OAAOC,IAAI,EAAE;MACT,IAAQzB,QAAQ,GAAK,IAAI,CAAjBA,QAAQ;MAChB,IAAIA,QAAQ,IAAIA,QAAQ,CAACmB,IAAI,KAAKvC,WAAW,CAACE,IAAI,EAAE;QAChDkB,QAAQ,CAACyB,IAAI,IAAIA,IAAI;QACrB,IAAI,IAAI,CAAChC,OAAO,CAACJ,cAAc,EAAE;UAC7BW,QAAQ,CAACe,QAAQ,GAAG,IAAI,CAACd,MAAM,CAACc,QAAQ;QAC5C;MACJ,CAAC,MACI;QACD,IAAMW,IAAI,GAAG,IAAI5C,IAAI,CAAC2C,IAAI,CAAC;QAC3B,IAAI,CAACH,OAAO,CAACI,IAAI,CAAC;QAClB,IAAI,CAAC1B,QAAQ,GAAG0B,IAAI;MACxB;IACJ;EAAC;IAAAtB,GAAA;IAAAC,KAAA,EACD,SAAAsB,UAAUF,IAAI,EAAE;MACZ,IAAI,IAAI,CAACzB,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACmB,IAAI,KAAKvC,WAAW,CAACG,OAAO,EAAE;QAC7D,IAAI,CAACiB,QAAQ,CAACyB,IAAI,IAAIA,IAAI;QAC1B;MACJ;MACA,IAAMC,IAAI,GAAG,IAAI3C,OAAO,CAAC0C,IAAI,CAAC;MAC9B,IAAI,CAACH,OAAO,CAACI,IAAI,CAAC;MAClB,IAAI,CAAC1B,QAAQ,GAAG0B,IAAI;IACxB;EAAC;IAAAtB,GAAA;IAAAC,KAAA,EACD,SAAAuB,aAAA,EAAe;MACX,IAAI,CAAC5B,QAAQ,GAAG,IAAI;IACxB;EAAC;IAAAI,GAAA;IAAAC,KAAA,EACD,SAAAwB,aAAA,EAAe;MACX,IAAMC,IAAI,GAAG,IAAIhD,IAAI,CAAC,EAAE,CAAC;MACzB,IAAM4C,IAAI,GAAG,IAAI1C,KAAK,CAAC,CAAC8C,IAAI,CAAC,CAAC;MAC9B,IAAI,CAACR,OAAO,CAACI,IAAI,CAAC;MAClBI,IAAI,CAACC,MAAM,GAAGL,IAAI;MAClB,IAAI,CAAC1B,QAAQ,GAAG8B,IAAI;IACxB;EAAC;IAAA1B,GAAA;IAAAC,KAAA,EACD,SAAA2B,WAAA,EAAa;MACT,IAAI,CAAChC,QAAQ,GAAG,IAAI;IACxB;EAAC;IAAAI,GAAA;IAAAC,KAAA,EACD,SAAA4B,wBAAwBhB,IAAI,EAAEQ,IAAI,EAAE;MAChC,IAAMC,IAAI,GAAG,IAAIxC,qBAAqB,CAAC+B,IAAI,EAAEQ,IAAI,CAAC;MAClD,IAAI,CAACH,OAAO,CAACI,IAAI,CAAC;IACtB;EAAC;IAAAtB,GAAA;IAAAC,KAAA,EACD,SAAAI,eAAeE,KAAK,EAAE;MAClB,IAAI,OAAO,IAAI,CAACnB,QAAQ,KAAK,UAAU,EAAE;QACrC,IAAI,CAACA,QAAQ,CAACmB,KAAK,EAAE,IAAI,CAACf,GAAG,CAAC;MAClC,CAAC,MACI,IAAIe,KAAK,EAAE;QACZ,MAAMA,KAAK;MACf;IACJ;EAAC;IAAAP,GAAA;IAAAC,KAAA,EACD,SAAAiB,QAAQI,IAAI,EAAE;MACV,IAAMK,MAAM,GAAG,IAAI,CAAChC,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACmC,MAAM,GAAG,CAAC,CAAC;MACtD,IAAMC,eAAe,GAAGJ,MAAM,CAACK,QAAQ,CAACL,MAAM,CAACK,QAAQ,CAACF,MAAM,GAAG,CAAC,CAAC;MACnE,IAAI,IAAI,CAACzC,OAAO,CAACL,gBAAgB,EAAE;QAC/BsC,IAAI,CAACW,UAAU,GAAG,IAAI,CAACpC,MAAM,CAACoC,UAAU;MAC5C;MACA,IAAI,IAAI,CAAC5C,OAAO,CAACJ,cAAc,EAAE;QAC7BqC,IAAI,CAACX,QAAQ,GAAG,IAAI,CAACd,MAAM,CAACc,QAAQ;MACxC;MACAgB,MAAM,CAACK,QAAQ,CAACb,IAAI,CAACG,IAAI,CAAC;MAC1B,IAAIS,eAAe,EAAE;QACjBT,IAAI,CAACY,IAAI,GAAGH,eAAe;QAC3BA,eAAe,CAACI,IAAI,GAAGb,IAAI;MAC/B;MACAA,IAAI,CAACK,MAAM,GAAGA,MAAM;MACpB,IAAI,CAAC/B,QAAQ,GAAG,IAAI;IACxB;EAAC;EAAA,OAAAT,UAAA;AAAA;AAEL,eAAeA,UAAU"},"metadata":{},"sourceType":"module"}